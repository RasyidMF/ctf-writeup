from z3 import *
from Crypto.Util.number import *
import gmpy2

cipher = 3568220602228030894234235833562306332059456831257470862490477842332889106330357717497935562917168335744490294025013583483080963708070777142559720398874438547446012190765227177289525226072247864455085523265693412608459421262810724000499062718407290037929844207006159430073923653091573172702861239928443239320542778093734748954368249583256502205604404332538408090259480134828986442222689278890718946795879671501029680816462977541688556779666783585593449309341969680748589935319628657917542748251463546769215830052399157026963904886704565816634869976303595537152533503067903716516412430091110229533674846808614180720700
n = 3931057479215986708746504999454647816614616133587799630551156682834832374445396020696347739510077736802054572777146963626825617441034009953891819320478509812486244457181370331899074262930587799069690953005197820710050882842952218995938680206230325498760489136992875076760593999307042295390557802467746722575161301522252369325458753689149767484505516805177851766680209043182161752479968000246655375676524647760198168646825338417822999924695817146431381939101557643082009525845029167895317478958544716653095995283728046691176435790369478143904715072221579162623390516475408174023812106193129905565299384183034607677427
hint = 3931057479215986708746504999454647816614616133587799630551156682834832374445396020696347739510077736802054572777146963626825617441034009953891819320478509812486244457181370331899074262930587799069690953005197820710050882842952218995938680206230325498760489136992875076760593999307042295390557802467746776931053048572187847797252282068198564595788076002007898520713515668527316461313547558044098710118442626837912008250075879359585523066510180827832526630849756052633293445318623478999832320790958696194699642596107256651255924849047384853241528176039659410185036114818966403826291209555272283812911955997679965116275
e = 65537

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b%a,a)
    return (g, x - (b//a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception("No modular inverse")
    return x%m

# Kita harus menemukan p dan q untuk mendapatkan flag
# def generateKeys(p, q):
#     e = 0x10001
#     n = p * q
#     phi = (p-1) * (q-1)
#     d = modinv(e, phi)
#     h = (p+0x69420) * (q+0x69420)
#     return [e, n, h]

# p1 = 0x69420
# q1 = 0x69420

# t = ((hint - n) / p1) - q1
# p, q = Int('p'), Int('q')

# # z3 untuk mencari nilai p dan q

# s = Solver()
# s.add(p + q == t)
# s.add(p * q == n)

# if s.check() == sat:
#     print s.model()

q = 56501137060995033936687590228888766501757157305279660543843950444454791488303035842416199169090319935056903912116895222441860599827608173113132664552533511053259964663995909521968454415373961939537484082250798529481483418414233195117349121632580945758147332529177543424406756960480587786057924581919699346839
p = 69574838378425324090644373532845463061794210613884663583007050879084289346303291579923381481410779295763713512175215041003877548977274310288117523658823805891763302434830153702422699454499656626250438066786424943413287789485498392842620207797352574245395776015686127338948199431709723722093210124000971762693

phi = (p - 1) * (q - 1)

d = modinv(e, phi)
m = pow(cipher, d, n)

print(bytearray.fromhex(str(hex(m))[2:-1]).decode())

# hacktoday{p_plus_q_is_solved__quick_maths_}